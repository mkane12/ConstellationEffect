// Adapted from Flowers and Animals
#pragma kernel Init

#define BLOCK_SIZE 16

struct InstanceData // data for an instance of a single star
{
    float3 startPosition; // starting position of stars (touch point)
    float3 position; // position of star on mesh
};

RWStructuredBuffer<InstanceData> _InstanceDataBuffer;

// This declares a variable that contains data the shader program will work wth. 
// Since we aren’t working with mesh data, you have to explicitly declare what data your compute shader will read and write to. 
// The “RW” in front of the datatype specifies that the shader will both read and write to that variable.
// RWStructuredBuffer<InstanceData> data;
//RWStructuredBuffer<float3> _Positions;

// Stuctured Buffer =  array of data consisting of a single data type (e.g. all int, or all float)
RWStructuredBuffer<float3> _Vertices;
float _Time, _TransitionProgress; 

float3 constellationPosition;
float3 constellationScale;
float4 constellationRotation;

// Quaternion multiplication
// http://mathworld.wolfram.com/Quaternion.html
float4 qmul(float4 q1, float4 q2)
{
    return float4(
        q2.xyz * q1.w + q1.xyz * q2.w + cross(q1.xyz, q2.xyz),
        q1.w * q2.w - dot(q1.xyz, q2.xyz)
    );
}

// Vector rotation with a quaternion
// http://mathworld.wolfram.com/Quaternion.html
float3 rotate_vector(float3 v, float4 r)
{
    float4 r_c = r * float4(-1, -1, -1, 1);
    return qmul(r, qmul(float4(v, 0), r_c)).xyz;
}

// sets position of star every update
void SetPosition(uint3 id)
{
    int starNum = id.x;
    
    float3 startPosition = constellationPosition;
    
    // transform position by scaling, rotating, then translating
    float3 endPosition = _Vertices[starNum] * constellationScale;
    endPosition = rotate_vector(endPosition, constellationRotation);
    endPosition = endPosition + constellationPosition;
    _InstanceDataBuffer[starNum].position = lerp(startPosition, endPosition, _TransitionProgress);
}

// TODO: Compute Shader will just run calculation to iterate over texture, but does not know about the texture itself
// The renderer is responsible for reading in the texture and rendering it

// This line specifies the dimensions of the thread groups being spawned by our compute shader. 
// GPUs take advantage of the massive parallel processing powers of the GPU by creating threads that run simultaneously. 
// Thread groups specify how to organize these spawned threads.

// id is a unique number, runs sequentially through threads
// num threads = _num_active_blocks * BLOCK_SIZE
[numthreads(BLOCK_SIZE, 1, 1)]
void Init(uint3 id : SV_DispatchThreadID)
{
    SetPosition(id);
}