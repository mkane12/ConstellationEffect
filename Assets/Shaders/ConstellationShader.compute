// Adapted from Flowers and Animals
#pragma kernel Init

#define BLOCK_SIZE 16

struct InstanceData // data for an instance of a single star
{
    float3 position; // position of star on mesh
};

RWStructuredBuffer<InstanceData> _InstanceDataBuffer;

// This declares a variable that contains data the shader program will work wth. 
// Since we aren’t working with mesh data, you have to explicitly declare what data your compute shader will read and write to. 
// The “RW” in front of the datatype specifies that the shader will both read and write to that variable.
// RWStructuredBuffer<InstanceData> data;
RWStructuredBuffer<float3> _Positions;

// Stuctured Buffer =  array of data consisting of a single data type (e.g. all int, or all float)
RWStructuredBuffer<float3> _Vertices;

float3 Interpolate(float x, float y, float3 t1, float3 t2, float3 t3)
{
    float aa = x;
    float bb = y;
    float cc = 1 - x - y;

    float3 p = aa * t1 + bb * t2 + cc * t3;
    return p;
}

void SetPosition(uint3 id)
{
    int starNum = id.x;
    _InstanceDataBuffer[starNum].position = _Vertices[starNum];

}

// This line specifies the dimensions of the thread groups being spawned by our compute shader. 
// GPUs take advantage of the massive parallel processing powers of the GPU by creating threads that run simultaneously. 
// Thread groups specify how to organize these spawned threads.

// id is a unique number, runs sequentially through threads
// num threads = _num_active_blocks * BLOCK_SIZE
[numthreads(BLOCK_SIZE, 1, 1)]
void Init(uint3 id : SV_DispatchThreadID)
{
    SetPosition(id);
}