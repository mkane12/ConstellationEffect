#pragma kernel Init

#define BLOCK_SIZE 16

struct InstanceData // data for an instance of a single star
{
    float3 startPosition; // starting position of stars (touch point)
    float3 position; // position of star on mesh
    float alpha; // star's transparency
    float lifespan; // star's lifespan
    float timeToFade; // time over which star fades
    int twinkleIndex; // index on sprite sheet for twinkle animation
};

RWStructuredBuffer<InstanceData> _InstanceDataBuffer;

// This declares a variable that contains data the shader program will work wth. 
// Since we aren’t working with mesh data, you have to explicitly declare what data your compute shader will read and write to. 
// The “RW” in front of the datatype specifies that the shader will both read and write to that variable.
// RWStructuredBuffer<InstanceData> data;
//RWStructuredBuffer<float3> _Positions;

// Stuctured Buffer =  array of data consisting of a single data type (e.g. all int, or all float)
RWStructuredBuffer<float3> _Vertices;
float _Time, _TransitionProgress,
    _Lifespan, _TimeToFade, _Duration; 

float3 constellationPosition;
float3 constellationScale;
float4 constellationRotation;

float _Alpha; // star alpha

int _TwinkleIndex; // index for sprite map in twinkle animation

// Quaternion multiplication
// http://mathworld.wolfram.com/Quaternion.html
float4 qmul(float4 q1, float4 q2)
{
    return float4(
        q2.xyz * q1.w + q1.xyz * q2.w + cross(q1.xyz, q2.xyz),
        q1.w * q2.w - dot(q1.xyz, q2.xyz)
    );
}

// Vector rotation with a quaternion
// http://mathworld.wolfram.com/Quaternion.html
float3 rotate_vector(float3 v, float4 r)
{
    float4 r_c = r * float4(-1, -1, -1, 1);
    return qmul(r, qmul(float4(v, 0), r_c)).xyz;
}

// sets position of star every update
void SetPosition(uint3 id)
{
    int starNum = id.x;
    
    float3 startPosition = constellationPosition;
    
    // transform position by scaling, rotating, then translating
    float3 endPosition = _Vertices[starNum] * constellationScale;
    endPosition = rotate_vector(endPosition, constellationRotation);
    endPosition = endPosition + constellationPosition;
    _InstanceDataBuffer[starNum].position = lerp(startPosition, endPosition, _TransitionProgress);
}

// causes stars to twinkle (cycle through texture map)
void Twinkle(uint3 id)
{
    int starNum = id.x;
    
}

// checks if fade is needed, then fades (called every Update)
void Fade(uint3 id)
{
    int starNum = id.x;
    
    // if it's time to fade, fade over time
    if (_Duration >= _Lifespan)
    {
        _Alpha = lerp(1., 0., clamp((_Duration - _Lifespan) / _TimeToFade, 0., 1.));
    }
    
    _InstanceDataBuffer[starNum].alpha = _Alpha;
}

// TODO: Compute Shader will just run calculation to iterate over texture, but does not know about the texture itself
// The renderer is responsible for reading in the texture and rendering it

// This line specifies the dimensions of the thread groups being spawned by our compute shader. 
// GPUs take advantage of the massive parallel processing powers of the GPU by creating threads that run simultaneously. 
// Thread groups specify how to organize these spawned threads.

// id is a unique number, runs sequentially through threads
// num threads = _num_active_blocks * BLOCK_SIZE
[numthreads(BLOCK_SIZE, 1, 1)]
void Init(uint3 id : SV_DispatchThreadID)
{
    SetPosition(id);
    Twinkle(id);
    Fade(id);
}